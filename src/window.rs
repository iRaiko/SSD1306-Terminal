use crate::i2c::I2c;
use std::io::Result;

/// A terminal type window for the SSD1306
pub struct Window
{
    screen: I2c,
    buffer: Vec<u8>,
    write_buffer: Vec<u8>,
    cursor_x: usize,
    cursor_y: usize,
}

impl Window
{
    /// Create a new Window and initialise the oled_screen;
    pub fn new(i2c_file_location: &str, slave_adress: i32) -> Result<Window>
    {
        let buffer = vec![0u8; ROWS_ON_SCREEN * BYTES_PER_ROW];
        let write_buffer = vec![0u8; BYTES_PER_ROW];
        let cursor_x = 0;
        let cursor_y = 0;
        let screen = I2c::new(i2c_file_location, slave_adress)?;
        let mut window = Window { buffer, write_buffer, cursor_x, cursor_y, screen};
        window.init_oled()?;
        Ok(window)
    }

    /// Turn the oled screen on.
    pub fn awaken(&mut self) -> Result<usize>
    {
        self.screen.write_command(0xAF)?;
        std::thread::sleep(std::time::Duration::new(0, 100000000)); // Time for screen to turn on
        Ok(0)
    }

    /// Turn the oled screen off.
    pub fn sleep(&mut self)-> Result<usize>
    {
        self.screen.write_command(0xAE)?;
        std::thread::sleep(std::time::Duration::new(0, 100000000)); // Time for screen to turn off
        Ok(0)
    }

    /// Print a string to the buffer area of the screen
    pub fn print_to_buffer(&mut self, content: &str) -> Result<usize>
    {
        let mut to_add = vec![0u8; BYTES_PER_ROW * ((content.len() / 16) + 1)];
        for (index, char) in content.chars().enumerate()
        {
            for bit in 0..8
            {
                to_add[(index * 8) + bit] = FONT[char as usize - 32][bit];
            }
        }
        self.buffer.extend_from_slice(&to_add);

        self.draw()
    }

    /// Print the write buffer to the buffer area on the screen
    pub fn print_write_buffer(&mut self) -> Result<usize>
    {
        self.buffer.extend_from_slice(&self.write_buffer);
        self.write_buffer = vec![0u8; BYTES_PER_ROW];
        self.cursor_x = 0;
        self.cursor_y = 0;

        self.draw()
    }

    /// Add a new character to the write buffer.
    pub fn add_char(&mut self, character: char) -> Result<usize>
    {
        for bit in 0..8
        {
            self.write_buffer[(self.cursor_y * 128) + (self.cursor_x * 8) + bit] = FONT[character as usize - 32][bit];
        }
        self.increment_cursor();

        self.draw()
    }

    /// Remove a character from the write buffer
    pub fn remove_char(&mut self) -> Result<usize>
    {
        self.decrement_cursor();
        for bit in 0..8
        {
            self.write_buffer[(self.cursor_y * 128) + (self.cursor_x * 8) + bit] = 0;
        }

        self.draw()
    }

    /// Increases the size of the writing area to make room for the new characters
    fn increase_size_of_write_area(&mut self) -> Result<usize>
    {
        self.write_buffer.extend_from_slice(&[0u8; BYTES_PER_ROW]);
        self.cursor_y += 1;
        self.draw()
    }

    fn decrease_size_of_write_area(&mut self)
    {
        if self.cursor_y == 0
        {
            self.cursor_x = 0;
        }
        else 
        {
            self.cursor_y -= 1;
        }

    }

    /// Moves the cursor one position to the right, and resets to 0 after reaching the right side of the screen
    fn increment_cursor(&mut self)
    {
        self.cursor_x += 1;
        if self.cursor_x > 15
        {
            self.cursor_x = 0;
            self.increase_size_of_write_area();
        }
    }

    fn decrement_cursor(&mut self)
    {
        if self.cursor_x == 0
        {
            self.cursor_x = 15;
            self.decrease_size_of_write_area();
        }
        else 
        {
            self.cursor_x -= 1;
        }
    }

    /// Draw an image on the screen
    pub fn draw_image(&mut self, data: &[u8]) 
    {
        self.screen.write_data(&data);
    }

    pub fn clear_screen(&mut self)
    {
        self.buffer = vec![0u8; ROWS_ON_SCREEN * BYTES_PER_ROW];
        self.draw();
    }

    /// Draw the complete buffers to the screen
    pub fn draw(&mut self) -> Result<usize>
    {
        let mut pixels = Vec::new();
        
        let size_of_write_area = self.write_buffer.len() / BYTES_PER_ROW;
        let buffer_total_rows = self.buffer.len() / BYTES_PER_ROW;
        let buffer_rows_in_view = ROWS_ON_SCREEN - size_of_write_area;
        let buffer_start = buffer_total_rows - buffer_rows_in_view;

        let buffer_window = &self.buffer[buffer_start * BYTES_PER_ROW..];

        pixels.extend_from_slice(buffer_window);
        pixels.extend_from_slice(&self.write_buffer);


        // Border between the buffer and where you write
        for x in 0..16
        {
            for bit in 0..8
            {
                pixels[((7 - size_of_write_area) * 128) + (x * 8) + bit] |= 0x80;
            }
        }

        // Cursor
        pixels[((7) * 128) + (self.cursor_x * 8)] |= 255;

        self.screen.write_data(&pixels)
    }

    /// Commands to initialise to OLED screen as per the datasheet.
    fn init_oled(&mut self) -> Result<usize>
    {
        self.screen.write_command(0xAE)?; // Display off

        self.screen.write_command(0x00)?; // Set lower column address
        self.screen.write_command(0x10)?; // Set higher column adress

        self.screen.write_command(0x40)?; // Set display start line

        self.screen.write_command(0xB0)?; // Set page adress

        self.screen.write_command(0x81)?; // Set contrast
        self.screen.write_command(0xCF)?; // contrast value 0-255

        self.screen.write_command(0xA1)?; // Set segment remap

        self.screen.write_command(0xA6)?; // normal / reverse

        self.screen.write_command(0xA8)?; // multiplex ratio
        self.screen.write_command(0x3F)?; // 1/64

        self.screen.write_command(0xC8)?; // Set com output scan direction

        self.screen.write_command(0xD3)?; // Display offset
        self.screen.write_command(0x00)?; // Display offset value

        self.screen.write_command(0xD5)?; // Set display clock
        self.screen.write_command(0x80)?; // display clock value

        self.screen.write_command(0xD9)?; // Set pre-charge period
        self.screen.write_command(0xF1)?; // pre-charge period value

        self.screen.write_command(0xDA)?; // Set COM pins
        self.screen.write_command(0x12)?; // Com pins value

        self.screen.write_command(0xDB)?; // Set VCOMH Deselect level
        self.screen.write_command(0x40)?; // level

        self.screen.write_command(0x8D)?;
        self.screen.write_command(0x14)?;

        self.screen.write_command(0xAF)?;

        self.screen.write_command(0x20)?; //
        self.screen.write_command(0x00)
    }

}

const BYTES_PER_ROW: usize = 128;
const ROWS_ON_SCREEN: usize = 8;
const CHARACTERS_PER_ROW: usize = 16;

const FONT:[[u8; 8]; 96] = 
    [[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    [0x00,0x00,0x5F,0x00,0x00,0x00,0x00,0x00],
    [0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x00],
    [0x00,0x14,0x7F,0x14,0x7F,0x14,0x00,0x00],
    [0x00,0x24,0x2A,0x7F,0x2A,0x12,0x00,0x00],
    [0x00,0x23,0x13,0x08,0x64,0x62,0x00,0x00],
    [0x00,0x36,0x49,0x55,0x22,0x50,0x00,0x00],
    [0x00,0x00,0x05,0x03,0x00,0x00,0x00,0x00],
    [0x00,0x1C,0x22,0x41,0x00,0x00,0x00,0x00],
    [0x00,0x41,0x22,0x1C,0x00,0x00,0x00,0x00],
    [0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00],
    [0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00],
    [0x00,0xA0,0x60,0x00,0x00,0x00,0x00,0x00],
    [0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00],
    [0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00],
    [0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00],
    [0x00,0x3E,0x51,0x49,0x45,0x3E,0x00,0x00],
    [0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x00],
    [0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x00],
    [0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00],
    [0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x00],
    [0x00,0x27,0x45,0x45,0x45,0x39,0x00,0x00],
    [0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x00],
    [0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x00],
    [0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00],
    [0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00],
    [0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00],
    [0x00,0x00,0xAC,0x6C,0x00,0x00,0x00,0x00],
    [0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x00],
    [0x00,0x14,0x14,0x14,0x14,0x14,0x00,0x00],
    [0x00,0x41,0x22,0x14,0x08,0x00,0x00,0x00],
    [0x00,0x02,0x01,0x51,0x09,0x06,0x00,0x00],
    [0x00,0x32,0x49,0x79,0x41,0x3E,0x00,0x00],
    [0x00,0x7E,0x09,0x09,0x09,0x7E,0x00,0x00],
    [0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x00],
    [0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x00],
    [0x00,0x7F,0x41,0x41,0x22,0x1C,0x00,0x00],
    [0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x00],
    [0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x00],
    [0x00,0x3E,0x41,0x41,0x51,0x72,0x00,0x00],
    [0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00],
    [0x00,0x41,0x7F,0x41,0x00,0x00,0x00,0x00],
    [0x00,0x20,0x40,0x41,0x3F,0x01,0x00,0x00],
    [0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x00],
    [0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x00],
    [0x00,0x7F,0x02,0x0C,0x02,0x7F,0x00,0x00],
    [0x00,0x7F,0x04,0x08,0x10,0x7F,0x00,0x00],
    [0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x00],
    [0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x00],
    [0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x00],
    [0x00,0x7F,0x09,0x19,0x29,0x46,0x00,0x00],
    [0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00],
    [0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x00],
    [0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x00],
    [0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x00],
    [0x00,0x3F,0x40,0x38,0x40,0x3F,0x00,0x00],
    [0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x00],
    [0x00,0x03,0x04,0x78,0x04,0x03,0x00,0x00],
    [0x00,0x61,0x51,0x49,0x45,0x43,0x00,0x00],
    [0x00,0x7F,0x41,0x41,0x00,0x00,0x00,0x00],
    [0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00],
    [0x00,0x41,0x41,0x7F,0x00,0x00,0x00,0x00],
    [0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x00],
    [0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00],
    [0x00,0x01,0x02,0x04,0x00,0x00,0x00,0x00],
    [0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x00],
    [0x00,0x7F,0x48,0x44,0x44,0x38,0x00,0x00],
    [0x00,0x38,0x44,0x44,0x28,0x00,0x00,0x00],
    [0x00,0x38,0x44,0x44,0x48,0x7F,0x00,0x00],
    [0x00,0x38,0x54,0x54,0x54,0x18,0x00,0x00],
    [0x00,0x08,0x7E,0x09,0x02,0x00,0x00,0x00],
    [0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x00,0x00],
    [0x00,0x7F,0x08,0x04,0x04,0x78,0x00,0x00],
    [0x00,0x00,0x7D,0x00,0x00,0x00,0x00,0x00],
    [0x00,0x80,0x84,0x7D,0x00,0x00,0x00,0x00],
    [0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00],
    [0x00,0x41,0x7F,0x40,0x00,0x00,0x00,0x00],
    [0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x00],
    [0x00,0x7C,0x08,0x04,0x7C,0x00,0x00,0x00],
    [0x00,0x38,0x44,0x44,0x38,0x00,0x00,0x00],
    [0x00,0xFC,0x24,0x24,0x18,0x00,0x00,0x00],
    [0x00,0x18,0x24,0x24,0xFC,0x00,0x00,0x00],
    [0x00,0x00,0x7C,0x08,0x04,0x00,0x00,0x00],
    [0x00,0x48,0x54,0x54,0x24,0x00,0x00,0x00],
    [0x00,0x04,0x7F,0x44,0x00,0x00,0x00,0x00],
    [0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00],
    [0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x00],
    [0x00,0x3C,0x40,0x30,0x40,0x3C,0x00,0x00],
    [0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00],
    [0x00,0x1C,0xA0,0xA0,0x7C,0x00,0x00,0x00],
    [0x00,0x44,0x64,0x54,0x4C,0x44,0x00,0x00], // z
    [0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x00],
    [0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00],
    [0x00,0x41,0x36,0x08,0x00,0x00,0x00,0x00],
    [0x00,0x02,0x01,0x01,0x02,0x01,0x00,0x00],
    [0x00,0x02,0x05,0x05,0x02,0x00,0x00,0x00]];